# QCBM imports
from orquestra.qml.models.qcbm.layer_builders import LineEntanglingLayerBuilder
from orquestra.qml.models.qcbm.ansatze.alternating_entangling_layers import (
    EntanglingLayerAnsatz,
)
from orquestra.qml.models.qcbm import WavefunctionQCBM
from orquestra.integrations.qulacs.simulator import QulacsSimulator
from orquestra.opt.optimizers.scipy_optimizer import ScipyOptimizer

# multi bases
from orquestra.qml.models.qcbm import MultiBasisWavefunctionQCBM
from orquestra.qml.models.qcbm import MultiBasisWavefunctionQCBM, RotationLayer
from orquestra.quantum.circuits import X, create_layer_of_gates
from orquestra.qml.api import ContinuousDistanceMeasure, DiscreteDistanceMeasure
from overrides import overrides
import torch
import numpy as np
import typing
from typing import Optional


class ExactNLLTorch(DiscreteDistanceMeasure):
    @overrides
    def measure_distance(self, true_probs: np.ndarray, pred_probs: np.ndarray) -> float:
        # Convert numpy arrays to PyTorch tensors and move them to the appropriate device
        device = "cuda" if torch.cuda.is_available() else "cpu"
        epsilon = 1e-10
        true_probs_torch = torch.from_numpy(true_probs).float().to(device)
        pred_probs_torch = torch.from_numpy(pred_probs).float().to(device)

        # Clip probabilities to avoid log(0)
        pred_probs_torch = torch.clamp(pred_probs_torch, min=epsilon)

        # Compute negative log likelihood
        nll = -torch.sum(true_probs_torch * torch.log(pred_probs_torch))

        # Move the result back to CPU and convert to python float for further usage
        return nll.cpu().item()


class QCBMPrior:
    def __init__(
        self, dim: int, n_layer: int = 2, back_end=QulacsSimulator(), optimizer=None
    ):

        super().__init__()
        self.dim = dim
        self.n_layer = n_layer
        if optimizer == None:
            self.optimizer = ScipyOptimizer(method="COBYLA", options={"maxiter": 1})
        else:
            self.optimizer = optimizer
        # initialize prior
        self.wave_function()

    def wave_function(self):
        entangling_layer_builder = LineEntanglingLayerBuilder(n_qubits=self.dim)

        qcbm_ansatz = EntanglingLayerAnsatz(
            n_qubits=self.dim,
            n_layers=self.n_layer,
            entangling_layer_builder=entangling_layer_builder,
        )
        self.prior = WavefunctionQCBM(
            ansatz=qcbm_ansatz,
            optimizer=self.optimizer,
            backend=QulacsSimulator(),
            choices=(0, 1),
            use_efficient_training=False,
            distance_measure=ExactNLLTorch(),
        )  #

        return self.prior

    @property
    def sample_size(self) -> typing.Tuple[int, ...]:
        """Returns the size of the samples generate by the model. This value does not include the batch dimension.

        Returns:
            Tuple[int, ...]: size of the samples generated by the model
        """
        return (self.dim,)

    def generate(
        self,
        n_samples: int,
        random_seed: Optional[int] = None,
        dtype: torch.dtype = torch.float32,
    ) -> torch.Tensor:
        """Get samples from the Gaussian sampler.
        Args:
            n_samples (int): Number of samples to get.
            random_seed (Optional[int], optional): Random seed to use.
                Defaults to None.
            dtype (torch.dtype): the dtype of the samples.
                Defaults to torch.float32.

        Returns:
            torch.Tensor: Samples with shape (n_samples, sampler_dimension).
        """

        return torch.from_numpy(self.prior.generate(n_samples)).float()

    def __repr__(self) -> str:
        return f"QCBM(dim={self.dim},n_layer={self.n_layer})"
